# Lab 06
Op dit moment voelt D3 misschien als een stap achterwaarts. D3 is inderdaad wat primitiever in zijn aanpak en dat is ook een bewuste keuze om flexibeler te kunnen zijn. We kunnen dingen in D3 die niet mogelijk zijn met Chart.js. In dit lab gaan we terug naar de grafieken en kijken we hoe we D3 kunnen gebruiken om simpele grafieken op te stellen. We kijken ook naar D3 scales om ons te helpen met het visualiseren van onze data.

## D3 Scales
Als we data visualiseren gebruiken we typisch een schaal. Als we het getal 21 000 willen plotten op een x-as dan doen we een vertaalslag naar pixels. We willen immers niet dat die 21 000 ook op 21 000 pixels wordt getekend. 
De meest eenvoudige schaal is een lineare schaal. We kunnen bijvoorbeeld stellen dat we al onze datapunten delen door 100 en dat gebruiken als onze pixelwaarde. 21 000 zou dan geplot worden op pixel 210 op de x-as.

Als onze data loopt van 0 tot 30 000, dan kunnen we op deze manier een herschaling laten berekenen door D3:

    const scale = d3.scaleLinear().domain([0, 30000]).range([0, 500]);

We krijgen dan een variabele, `scale` wat in wezen een functie is, die we kunnen gebruiken voor onze vertaalslag. Willen we weten op welke pixel 13340 uitkomt, dan kan dat als volgt:

    console.log(scale(13340));

We gaan nu zo een schaal gebruiken om een grafiek te tekenen. We gaan er zelfs 2 gebruiken! Eentje voor onze X-as en eentje voor onze Y-as. We gebruiken de volgende data:

    const data = [
        {x: 5, y: 20},
        {x: 15, y: 35},
        {x: 25, y: 40},
        {x: 35, y: 60},
        {x: 45, y: 80}
    ];

We stellen een schaal op voor onze X-as:

    const xScale = d3.scaleLinear().domain([0, 50]).range([40, 460]);

✅ Stel nu zelf een `yScale` op die waarden tussen 0 en 100 herschaalt tussen 260 en 20. Dit is een geinverteerde schaal, dus lagere waarden zullen vertaalt worden naar een hogere pixelwaarde! Zie oplossing 1.

## Assen
We kunnen D3 scales gebruiken om D3 assen voor ons te laten tekenen. We zoeken eerst ons SVG element:

    svg.append("g")
        .attr("transform", "translate(0,260)")
        .call(d3.axisBottom(xScale));

    svg.append("g")
        .attr("transform", "translate(40,0)")
        .call(d3.axisLeft(yScale));

Je ziet dat we de waardes 260 en 40 voor onze scales bewust gekozen hebben want dat zijn de plaatsen waarop onze assen getekend worden. We geven hier geen lengtes mee aan de assen, die worden afgeleid uit de scales die we meegegeven hebben.

✅ Plot nu kleine cirkels op deze grafiek om een scatter plot te maken aan de hand van de data. Geef straal 5 aan elke cirkel. Zie oplossing 2.
✅ Voeg labels toe aan de X-as ("X Waarde") en Y-as ("Y Waarde").
✅ Zoek zelf op hoe je, aan de hand van de `tick` methode, kan bepalen hoeveel intervallen er getekend worden op een as. Zorg dat er 5 intervallen worden getekend op de x-as.

## Enter-Update-Exit
We hebben al geleerd dat D3 gebruik maakt van een enter en exit gedrag om elementen dynamisch toe te voegen en weg te halen als de selectie niet overeenkomt met de data. Daar gaan we nu wat dieper op in om een dynamische bar chart te maken. De workflow ziet er grosso modo zo uit:

    const bars = svg.selectAll("rect")
    .data(data);

    // Enter
    bars.enter()
    .append("rect")
    .attr("height", d => d);

    // Update
    bars.attr("height", d => d);

    // Exit
    bars.exit().remove();

Zoals steeds starten we met data:

    const data = [25, 40, 15, 60, 30];

We gaan onze scales wat dynamischer opbouwen. Onze data loopt van 0 tot 60, maar die 60 krijgen we ook door:

    d3.max(data)

Dus we gaan de volgende y-scale gebruiken:

    const yScale = d3.scaleLinear().domain([0, d3.max(data)].range([260, 20]));
    
Voor de x-scale gebruiken we:

    const xScale = d3.scaleBand()
        .domain(d3.range(data.length))
        .range([40, 460])
        .padding(0.1);

`scaleBand` is een scale die beschikbare ruimte (40 - 460) eerlijk probeert te verdelen en laat daarbij wat ruimte (de padding). Hier is een voorbeeld:

    const x = d3.scaleBand.domain(["a", "b", "c"]).range([0, 960]);
    x("a"); // 0
    x("b"); // 320
    x("c"); // 640
    x("d"); // undefined

De `d3.range` genereert simpelweg een reeks van getallen:

    d3.range(5); // [0, 1, 2, 3, 4]

Nu gaan we onze bars genereren:

    svg.selectAll("rect")
        .data(data)
        .enter()
        .append("rect")
        .attr("x", (d, i) => xScale(i))
        .attr("y", d => yScale(d))
        .attr("width", xScale.bandwidth())
        .attr("height", d => 260 - yScale(d))
        .attr("fill", "steelblue");

✅ Voeg zelf opnieuw de assen toe

We gaan nu zorgen dat onze grafiek automatisch aanpast op basis van nieuwe data. Daarvoor voegen we een functie toe:

    function updateChart(newData)
    {

    }

We stellen onze visualisatie in die functie simpelweg opnieuw op, op basis van `newData`. We starten met een selectie:

    const bars = svg.selectAll("rect")
        .data(newData);

Vervolgens definieren we opnieuw wat er moet gebeuren als er rechthoeken moeten worden toegevoegd:

    // Enter new
    bars.enter()
        .append("rect")
        .attr("x", (d, i) => xScale(i))
        .attr("y", yScale(0))
        .attr("width", xScale.bandwidth())
        .attr("height", 0)
        .attr("fill", "steelblue")
        .transition()
        .duration(500)
        .attr("y", d => yScale(d))
        .attr("height", d => 260 - yScale(d));

We zeggen ook wat er moet gebeuren als er bars moeten verdwijnen:

    // Exit old
    bars.exit()
        .transition()
        .duration(500)
        .attr("height", 0)
        .remove();

Hier zien we in beide gevallen voor het eerst `transition`. De meeste simpele vorm was dit geweest:

    // Exit old
    bars.exit()
        .remove();

Maar dat is ook een bruuske overgang. Door middel van de `transition` functie zijn we tegen D3 aan het zeggen dat we een verandering gaan specifieren maar dat we willen dat deze verandering geleidelijk gebeurt. In dit geval zetten we de hoogte van een balk op 0. `transition` wordt steeds gevolgd door `duration` die aangeeft (in ms) hoe lang de overgang moet duren.

Ten slotte specifieren we nog wat er moet gebeuren met de balken die bewaart blijven. We gebruiken opnieuw transition:

    // Update existing
    bars.transition()
        .duration(500)
        .attr("y", d => yScale(d))
        .attr("height", d => 260 - yScale(d));

Probeer de `updateChart` functie maar eens af te roepen met de volgende data: [50, 20, 70, 40].
De volledige code, inclusief een kleine demo die de chart update na 2 seconden vind je hieronder:

    import * as d3 from 'd3';

    const svg = d3.select('#mysvg');
    const data = [25, 40, 15, 60, 30];

    const yScale = d3.scaleLinear().domain([0, d3.max(data)]).range([260, 20]);
    const xScale = d3.scaleBand()
        .domain(d3.range(data.length))
        .range([40, 460])
        .padding(0.1);

    svg.append("g")
        .attr("transform", "translate(0,260)")
        .call(d3.axisBottom(xScale));

    svg.append("g")
        .attr("transform", "translate(40,0)")
        .call(d3.axisLeft(yScale));

    updateChart(data);

    async function demo()
    {
        await sleep(2000);
        updateChart([50, 20, 70, 40])
    }
    demo();

    function sleep(time) {
        return new Promise((resolve) => setTimeout(resolve, time));
    }

    function updateChart(newData) {
        const bars = svg.selectAll("rect")
            .data(newData);

        // Enter new
        bars.enter()
            .append("rect")
            .attr("x", (d, i) => xScale(i))
            .attr("y", yScale(0))
            .attr("width", xScale.bandwidth())
            .attr("height", 0)
            .attr("fill", "steelblue")
            .transition()
            .duration(500)
            .attr("y", d => yScale(d))
            .attr("height", d => 260 - yScale(d));

        // Exit old
        bars.exit()
            .transition()
            .duration(500)
            .attr("height", 0)
            .remove();

        // Update existing
        bars.transition()
            .duration(500)
            .attr("y", d => yScale(d))
            .attr("height", d => 260 - yScale(d));
    }

## Huiswerk
Maak een lijngrafiek met behulp van d3. Gebruik de volgende data:

| Month | **Sales** |
| ----- | --------------------- |
| Jan   | 12,000                |
| Feb   | 15,000                |
| Mar   | 13,500                |
| Apr   | 16,000                |
| May   | 18,000                |
| Jun   | 17,500                |
| Jul   | 20,000                |
| Aug   | 22,000                |
| Sep   | 21,000                |
| Oct   | 23,000                |
| Nov   | 25,000                |
| Dec   | 30,000                |

Zorg dat de assen netjes getekend worden aan de hand van zinvolle scales. Voeg een knop toe. Als je op de knop klikt krijg je voor elke maand een willekeurig cijfer tussen 10 000 en 30 000. Je kan daarvoor `Math.random()` gebruiken. De grafiek zal dan natuurlijk ook terug updaten. Maak ook gebruik van `transition` om de overgangen netjes te animeren.

## Oplossingen

### Oplossing 1
    const yScale = d3.scaleLinear().domain([0, 100]).range([260, 20]);

### Oplossing 2
    svg.selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 5)
        .attr("fill", "steelblue");
