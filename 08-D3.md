# Lab 08
Dit is ons laatste lab met grote nieuwigheden van D3. We gaan leren hoe we datas kunnen opschonen en transformeren met D3. Chart.js draait om het tekenen van grafieken en we hebben gezien dat we dat ook kunnen met D3, maar D3 bevat ook een groot luik aan tools om data te verwerken en te converteren, zoals we reeds gezien hebben bij het transformeren van datumobjecten met D3.

## Inlezen van JSON data
We hebben bij Chart.js al gezien hoe we via JS een JSON file kunnen inladen. Dat kan ook met D3. Maak in je public folder een `prodcuts.json` file aan en vul met:

    [
        { "id": 1, "name": "Laptop", "price": "1200", "category": "Electronics" },
        { "id": 2, "name": "Chair", "price": "150", "category": "Furniture" }
    ]

Inlezen kunnen we als volgt:

    d3.json("products.json").then(data => {
        console.log(data);
    });

Dit is opnieuw een asynchrone functie, vandaar de `then`. Nadat de data is ingelezen wordt dus de volgende functie aangeroepen:

    data => {
        console.log(data);
    }

`data` is hier een variabele die je zelf een naam mag geven en bevat de rauwe data die is ingelezen door D3.

## Inlezen van CSV data
Naast JSON, is CSV een populair formaat om data in op te slaan, niet in het minst omdat Excel een goede ondersteuning biedt voor het exporteren en importen van CSV data. CSV staat voor comma seperated value. De data die we hierboven gebruikt hebben zou er als volgt uitzien in CSV:

    id, name, price, category
    1, Laptop, 1200, Electronics
    2, Chair, 150, Furniture

Je bekijkt dit het best als een tabel. De eerste rij bevat de hoofdingen en de kolommen worden opgedeeld aan de hand van een komma. Zo dus:

| id | name | price | category|
| -- | ---- | ----- | ------- |
| 1 | Laptop | 1200 | Electronics |
| 2 | Chair | 150 | Furniture |

Het inlezen van een CSV file gaat in D3 net zo vlot als het inlezen van een JSON file. Maak een nieuwe file aan in je public folder en noem die `sales.csv`:

    date,region,sales
    2025-01-01,North,120
    2025-01-02,South,150
    2025-01-03,North,90
    2025-01-03,East,200

Inlezen is eenvoudig en werkt op dezelfde manier als json:

    d3.csv("sales.csv").then(data => {
    console.log(data);
    });

## Parsing en Conversies
We houden ons voorbeeld klein, maar denk eraan dat dit ook werkt op grote datasets. We kijken opnieuw naar onze `sales.csv`. We kunnen een functie invoegen in de aanroep naar `csv` die een functie zal uitvoeren voor elk elementje, net zoals de map functie. In principe kan je ook gewoon de `map` functie gebruiken zoals je geleerd hebt in het vorige labo, dit is gewoon een alternatieve syntax:

    d3.csv("sales.csv", d => {
    return {
        date: d3.timeParse("%Y-%m-%d")(d.date),
        region: d.region,
        sales: +d.sales
    };
    }).then(data => console.log(data));

Het omzetten van een string naar een getal kan eenvoudig door een `+` te zetten voor de variabele, dat forceert JS om naar de waarde te kijken als een getal. We verwijzen naar het vorig labo met de uitleg over `timeParse`.

Wat meer uitgeschreven, met `map`, ziet er dat zo uit:

    const salesDataRaw = await d3.csv("sales.csv");
    const salesData = salesDataRaw.map(d => ({
        date: d3.timeParse("%Y-%m-%d")(d.date),
        region: d.region,
        sales: +d.sales
    }));
    console.log(salesData);

Data filteren kan met de ... `filter` functie:

    const above100 = salesData.filter(d => d.sales > 100);
    const northOnly = salesData.filter(d => d.region == "North")

Conversie kan via de `map` functie:

    const salesOnly = salesData.map(d => d.sales);
    const byDate = salesData.map(d => ({ x: d.date, y: d.sales}))

## Groupby en Rollup
Een belangrijk element bij het visualiseren van data is het groeperen van data: wat is de gemiddelde verkoop van al onze electronica toestellen? Wat is het populairste genre op Netflix? Welke leeftijd preseteert het beste op lange afstandsloop? etc.

Daarvoor gebruiken we een complexe functie genaamd `rollup`. We leren dat met een voorbeeld!

Verander de inhoud van `sales.csv`:

    date,region,product,sales
    2025-01-01,North,Laptop,120
    2025-01-01,North,Phone,80
    2025-01-01,South,Laptop,100
    2025-01-02,East,Laptop,200
    2025-01-02,North,Phone,60
    2025-01-02,South,Chair,75
    2025-01-03,North,Chair,90
    2025-01-03,East,Phone,150
    2025-01-03,South,Laptop,130

✅ Lees deze data in en converteer. Zie oplossing 1.

Het vraagstuk dat we willen beantwoorden is wat de verkoop is per regio. `rollup` doet dit voor ons en verwacht 3 stukken input:

- De data die we moeten opdelen
- De "group key" - dat is het attribuut waarop we willen onderverdelen. In ons geval is dat de regio.
- Een aggregator - Dit is een functie die van een groep terug een getal gaat maken. Dat kan bijvoorbeeld de hoeveelheid leden zijn in een groep, een gemiddelde, een minimum, een maximum, een optelling, etc.

On ons geval willen we opdelen per regio. Als je de bovenstaande data zou opdelen per regio zou je drie groepen krijgen:

    2025-01-01,North,Laptop,120
    2025-01-01,North,Phone,80
    2025-01-02,North,Phone,60
    2025-01-03,North,Chair,90

    2025-01-02,East,Laptop,200
    2025-01-03,East,Phone,150

    2025-01-01,South,Laptop,100
    2025-01-02,South,Chair,75
    2025-01-03,South,Laptop,130

Merk op dat we geen data hebben voor de rtegio "West". Er zal natuurlijk niet automatisch een lege 4e groep worden aangemaakt. Wil je simpelweg deze groepen hebben, dat kan met de functie `group`:

    const regionGroups = d3.group(salesData, d => d.region);
    console.log(regionGroups);

De output hiervan is een `map` datastructuur (niet te verwarren met de `map` functie). Wil je de 4 datapunten uit het Noorden hebben dan kan dat zo:

    const northSales = regionGroups["North"];

✅ Dit is een goede test voor je JS skills: bereken mij het gemiddelde van de sales in het Noorden, het minimum van de sales in het Oosten en de som van de sales in het Zuiden.

We hebben nu al 2 van de ingredienten voor onze `rollup`:

    const salesByRegion = d3.rollup(
        salesData,
        ...,
        d => d.region
    );

Wat ontbreekt in het midden is onze aggregator. In wat zijn we eigenlijk geinteresseerd? Het gemiddelde van elke groep? Het minimum? etc. Laat ons stellen dat we willen weten wat de totale sales zijn in elke regio. Op die manier kunnen we ook ontdekken wat onze beste regio is. Dat ziet er zo uit:

    const salesByRegion = d3.rollup(
        salesData,
        v => d3.sum(v, d => d.sales),  
        d => d.region                  
    );

De aggregator 

    v => d3.sum(v, d => d.sales),  

neemt een `v` als input (zelf te kiezen), dit is een group, dus de aggregator zal in ons geval 3 maal opgeroepen worden. Voor elke groep nemen we de som op basis van het `sales` attribuut. Dit geeft ons een getal per regio. De regio en het getal worden gebundeld en dat is de output van rollup. 
De output van onze `rollup` ziet er dus zo uit:

    [ ["North", 350], ["South", 305], ["East", 350] ]

## Huiswerk
In de data folder bij deze cursus vind je `mobile_game_inapp_purchases.json`. Lees deze data in. Je gaat een visualisatie maken van de hoeveelheid aankopen per leeftijdscategorie. We willen weten welke leeftijden het meeste spenderen.
Visualiseer deze data in een bar chart met behulp van D3. Als ik zweef over een balk dan moet die van kleur veranderen en ik moet de data kunnen aflezen van een tooltip die verschijnt. Indienen doe je via blackboard. Veel succes!

## Oplossingen
### Oplossing 1

    const salesDataRaw = await d3.csv("sales.csv");
    const salesData = salesDataRaw.map(d => ({
        date: d3.timeParse("%Y-%m-%d")(d.date),
        region: d.region,
        product: d.product,
        sales: +d.sales
    }));
    console.log(salesData);