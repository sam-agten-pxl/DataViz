# Lab 07
Dit lab is wat uitgebreider. We gaan dieper in op de tekenfunctionaliteit van D3 en doen ook aan wat dataverwerking (specifiek voor datums). We leren generators gebruiken om paden te tekenen en voegen wat interactieve tooltips toe aan onze grafieken.

## Werken met datums
Iets wat steeds to frustratie kan leiden in het werken met data is tijdstippen. Nochtans is tijd een zeer voorkomend soort data, dus laat ons eens kijken naar hoe waar correct mee omgaan. We starten met de volgende data:

    const raw = [
        { date: "2025-01-01", value: 22 },
        { date: "2025-01-03", value: 28 },
        { date: "2025-01-05", value: 18 },
        { date: "2025-01-06", value: 26 },
        { date: "2025-01-08", value: 30 },
        { date: "2025-01-10", value: 24 },
        { date: "2025-01-12", value: 32 },
        { date: "2025-01-14", value: 29 }
    ];

Het is belangrijk dat je het verschil snapt tussen datatypes. Datum als `string` type zijn niet werkbaar. Wat we willen is een javascript [date] object. Zo een `date` object werkt immers veel gemakkelijker. We kunnen tijdzones veranderen, polsen naar minuten, uren, seconden, tijden vergelijken, etc. Het is een goede oefening om die zaken eens te proberen met teksobjecten!
De omzetting van een stuk tekst naar een datum object is niet triviaal. Neem bijvoorbeeld: "2025-01-02". Staat de 1 hier voor de maand of de dag? Het antwoord kan verschillen afhankelijk van waar je bent in de wereld. Bovendien kunnen we deze datum ook schrijven als: "01/02/2025" of "1 FEB 2025". 

Om de tijd correct om te zetten hebben we een formatter nodig. Dat is een notatievorm die D3 gaat gebruiken om een `string` te interpreteren als datum. Dat ziet er zo uit:

    const parseDate = d3.timeParse("%Y-%m-%d");

Dit genereert een functie, net zoals de `scale` functies die we reeds gezien hebben voor D3. In gebruik ziet er dat dus zo uit:

    const date = parseDate("2025-01-01");

In de `timeParse` functie geven we mee dat de datum in de volgende vorm zal staan: X-X-X. We geven dan aan hoe elk deel geinterpreteerd moet worden aan de hand van een [format]:

- %Y: Dit betekent dat D3 moet zoeken naar een jaar in volledige notatie: 2025. Een alternatief zou zijn %y en dat betekent dat hier het jaar zal staan in korte notatie, bijvoorbeeld 25.
- %m: Dit wil zeggen de maand in korte notatie: 01 - 12. Alternatieven zijn %b (bv Jan) of %B (bv January).
- %d: Dit wil zeggen de dag in korte notatie: 01 - 31.

Probeer zeker de volgende code eens:

    const test = parseDate(raw[0].date);
    console.log(test);

Je zal zien dat je output krijgt in de volgende vorm:

    Wed Jan 01 2025 00:00:00 GMT+0100 (Central European Standard Time)

Dan weet je zeker dat formatter correct is. Test altijd eerst je formatter!

[date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
[format]: https://devhints.io/datetime

## Dataconversie op schaal
Het is geen toeval dat ik de data hierboven `raw` heb genoemd. Dit is onze rauwe, onbewerkte data. Typisch, voordat we een visualisatie maken van data, gaan we die eerst bewerken. Dat kan gaan van het filteren van ongewenste waardes tot het berekenen van extra velden zoals gemiddeldes. Ook dataconversie hoort bij dit proces en het vervangen van `string` objecten is daarbij een heel belangrijke. Onze grote helper daarvoor is de `map` functie van Javascript. We hebben die al eens zien passeren, maar kort gezegd: de `map` functie overloopt een array, doet iets voor elk element (dat hopelijk een resultaat produceert) en geeft ons de nieuwe array terug. Heb je bijvoorbeeld een array van punten hebben in kommagetallen, maar zou je liever diezelfde array willen met afgeronde getallen, dan is `map` de functie die je daarbij kan assisteren. De vorm die `map` aanneemt is de volgende:

    const data = raw.map(d => ...);

`map` verwacht dus een functie, de input van die functie is een variabele die een element is uit de array `raw`. Een nieuwe array zal gegenereerd worden die even groot is als `raw` en voor elk element het resultaat bevat van de functie die als input het overeenkomstig element uit `raw` gehad heeft. Hier is een eenvoudig voorbeeld:

    const testArray = [1, 2, 3];
    const newArray = testArray.map(x => x + 1);
    console.log(newArray);

De output hiervan is `[2, 3, 4]`. We hebben elk element `x` uit `testArray` genomen, daar +1 bij opgeteld en in een nieuwe array `newArray` gestoken. In het geval van `raw` krijgen we wel een object als `d`, niet een getal, dus onze output is opnieuw een object:


    const data = raw.map(d => {date: ..., value: ...});

Dat moet niet zo zijn, overigens. We kunnen een heel ander object teruggeven! We kunnen bijvoorbeeld het `value` veld wegfilteren:

    const data = raw.map(d => {date: ...});

Of een nieuw veldje toevoegen:

    const data = raw.map(d => {date: ..., value: ..., average: ...});

In ons geval gaan we niets te zot doen, maar enkel dataconversie.
✅ Gebruik de `map` functie om dataconversie te doen en onze `strings` om te zetten naar een `date` object met behulp van onze formatter.
✅ Zet ook onze `value` om naar een getal
✅ Sorteer bovendien onze array volgens datum

Oplossing vind je als oplossing 1

## Grafiek tekenen
Oef - laat ons nu even teruggrijpen naar het tekenen van een grafiek. Laat me jullie ook eens een lichtjes andere aanpak demonstreren. We gaan zoveel mogelijk in code doen, en niet in HTML of CSS. Mijn HTML ziet er als volgt uit:


    <body>
        <h1>D3 werken met Tijd</h1>
        <div id="chart"></div>
        <script type="module" src="/src/main.js"></script>
    </body>

We starten met enkele variabele te definieren die ons gaan helpen bij het tekenen van de grafiek:

    const margin = { top: 20, right: 28, bottom: 36, left: 48 };
    const width  = 760 - margin.left - margin.right;
    const height = 380 - margin.top - margin.bottom;

Merk op dat we de `width` definieren in termen van onze marges. We gaan deze variabelen gebruiken om onze SVG toe te voegen en correct te zetten met behulp van d3:

    const svg = d3.select("#chart")
        .append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

Onze SVG viewbox komt dus uit op `0 0 760 380`. Run en controleer gerust met de dev console of we op de goede weg zijn! Er is nog niet veel te zien op onze webpagina, maar je kan dit werk zeker al controleren!
Merk op dat we ook een `g` elementje toevoegen dat start vanuit de correcte marge, hier kunnen we onze grafiek straks op tekenen. Ons SVG canvas is ietsje groter zodat we wat marge houden van mogelijke andere HTML elementen.

We voegen nu onze y-as toe. Daarvoor maken we eerst een scale:

  const y = d3.scaleLinear()
    .domain([0, d3.max(data, d => d.value)]).nice()
    .range([height, 0]);

Je vraagt je misschien af wat die `nice()` daar doet. Die zorgt ervoor dat de waardes netjes afgerond worden zodat onze labeltjes op de assen mooi leesbaar worden.

We tekenen nu de as:

  svg.append("g")
    .call(d3.axisLeft(y));

Als DVO student vraag je je nu natuurlijk af hoe je die as mooi kan maken in de plaats van te blijven werken met de default styling van D3. Dat kan door een klasse toe te voegen:

  svg.append("g")
    .attr("class", "axis")
    .call(d3.axisLeft(y));

Die kan je dan bewerken in je CSS naar believe:

    .axis line { stroke: #999; }

Hoe maken we nu onze x-as met de datums? Dat is een tikkeltje complexer maar gelukkig niet veel. Starten doen we met een scale functie.

✅ Schrijf zelf een scale functie `x` voor onze datums. Oplossing vind je onder onder oplossing 2.

Dan gebruiken we die om een as te tekenen:

    svg.append("g")
      .attr("class", "axis")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x).ticks(d3.timeDay.every(2)).tickFormat(d3.timeFormat("%b %d")));

We zoomen even in op die laatste regel:

    d3.axisBottom(x). ticks( d3.timeDay.every(2) ). tickFormat( d3.timeFormat("%b %d") )

- `ticks` hebben we al gezien. Dit bepaalt de intervallen op onze as. De input hiervan is echter wat eigenaardig. We gebruiken `timeDay.every` van D3 (Begin je in te zien dat D3 een library is die heel wat handige functies bevat voor dataverwerking, in tegenstelling tot Chart.js?) om een interval te maken van n dagen, in ons geval 2.
- `tickFormat` is niet exclusief voor datums, maar geeft aan in welk format de labeltjes getekend moet worden. Voor datums gebruiken we hier wel `timeFormat`, een functie die opnieuw een formatnotatie verwacht en dus elk labeltje in dat format zal tekenen. 

Hoe tekenen we nu een lijn met D3? Daarvoor gebruiken we de `line()` functie. Een lijn in D3 is een object, een collectie van (x, y) coordinaten. Als we een lijn willen opstellen moeten we dus een reeks van x-waarden en een reeks van y-waarden geven:

  const line = d3.line()
    .x(d => x(d.date))
    .y(d => y(d.value));

Merk op dat we hier niet onze `data` gebonden hebben aan deze lijn. Dit kan je dus vergelijken met een formatter, we geven enkel aan hoe de lijn in elkaar zit: x-waardes haal je bij `date` en y-waardes bij `value`. D3 noemt dit een **generator**: het is een notatie om aan te geven hoe een lijn opgesteld moet worden, los van de data zelf. 
We kunnen deze lijn tekenen met een SVG `path` elementje:

    svg.append("path")
        .datum(data)
        .attr("d", line);

We kennen de generator dus toe aan een attribuut `d` om het pad te tekenen. We gebruik hier ook `datum` in de plaats van `data` om onze data binding te doen. De uitleg waarom we hier datum gebruiken in de plaats van data zou ons echter wat te ver leiden, dus onthoud dit als een uitzondering. Als je nu naar je grafiek kijkt zal je zien dat dit pad getekend wordt met een `fill` kleur en dus op niet veel trekt.

✅ Pas de code aan zodat de lijn netjes getekend wordt in `steelblue` met een lijnbreedte van 2. Zie oplossing 3.
✅ Zoek zelf een naar een manier om deze 'lijn' te tekenen als een mooie curve, zonder de scherpe hoeken. Dit kan op verschillende manieren. Een manier vind je in oplossing 4.

## Area generator
We kunnen die methode van de generator ook gebruiken om een gesloten pad tekenen. Zo kunnen we bijvoorbeeld het gebied onder de lijn een kleur geven, door een pad te maken dat de lijn volgt maar ook langs de assen afloopt en terug sluit.
Een generator die ons daarbij helpt is de `area` generator. Een area generator pakt een x-waarde, maar 2 verschillende y-waardes: y0 en y1, eentje voor de bovenlijn en eentje voor de onderlijn. Zoek zelf uit hoe je een area generator kan maken op basis van de documentatie. Hier is de algemene vorm:

    const area = d3.area()
    .x(...)         
    .y0(...)
    .y1(...);

✅ Teken en vul nu het gebied onder de lijn met de kleur `rgba(54, 162, 235, 0.2)`. Gebruik een generator en een `path`. Zie oplossing 5.
✅ Extra uitdaging nodig? Zoek ook een slimme manier om het tekenen van assen te misbruiken om gridlijnen te tekenen op onze grafiek. Voor elke van onze labeltjes op onze y-as wil ik dat er een dunne, horizontale, lichtgrijze lijn wordt getekend. Zie oplossing 6.

## Interactiviteit
Zonder interactiviteit is niets wat we hier doen de moeite, dan zouden we onze grafieken immers beter maken in illustrator of ... *kuch* ... Excel. 
Interactiviteit in D3 gebruikt simpelweg de standaard JS manieren om events te capteren. De vorm is als volgt:

    selection.on("eventType", (event, d) => { … });

Een event is dan bijvoorbeeld `mouseover`, `mouseout`, `click`, `dblclick`, etc. Bijvoorbeeld:

    svg.selectAll("rect")
    .on("mouseover", function(event, d) {
        d3.select(this).attr("fill", "orange");
    })
    .on("mouseout", function() {
        d3.select(this).attr("fill", "steelblue");
    });

Zorgt ervoor dat een rect van kleur verandert als we met onze muis erover gaan.

✅ Zorg dat de lijn en het gebied onder de lijn oranje oplicht als we met de muis er over gaan.

We gaan er nu voor zorgen dat er cirkel en een lijn getekend wordt als we met onze muis in de buurt komen van een datapunt. We doen hier de cirkel voor, de lijn voeg je zo dadelijk als oefening zelf toe. We voegen een nieuw `g` elementje toe waaronder we de cirkel en de lijn gaan toevoegen:

    const focus = svg.append("g").style("fill", "none").style("stroke", "#333");
    focus.append("circle").attr("r", 4);


✅ Voeg aan `focus` ook een `line` toe die loopt van 0 (y1) naar `height` (y2). De lijn is een stippellijn. De kleur is `#aaa`.

We tekenen nu een onzichtbare rechthoek bovenop onze SVG:

    svg.append("rect")
        .attr("fill", "transparent")
        .attr("pointer-events", "all")
        .attr("width", width)
        .attr("height", height)

deze rechthoek laten we luisteren naar `all` pointer-events. We maken eerst snel een functie die naar ons mouse event gaat luisteren:

    function onMove(event)
    {
        console.log("mouse event");
    }

We koppelen dan ons event nog aan die rechthoek:

    ...
    .on("mousemove", onMove)

Test eerst even deze code.
Hou je kopje er even bij, want het volgende stuk is wat ingewikkeld. We willen immers weten welk datapunt het dichtste bij onze muiscursor is. Dus we gaan van pixels naar een datapunt en terug naar pixels. Bij zulke complexe problemen raad ik aan om je probleem in kleine deelproblemen op te delen. Denk eens na over de volgende 2 zaken:


✅ Hoe kan ik de huidige x-positie krijgen in onze `rect`? We willen graag de x-positie ten opzichte van de de rechthoek, dus als we met onze muis de linkerkant raken van de `rect`, dan zou x 0 moeten zijn. Tip: zoek eens naar `d3.pointer`.

✅ Als ik een correct x-waarde heb, hoe kan ik dan onze `focus` op die x-waarde zetten? Tip: denk aan `translate` uit de vorige labs.

Ik breid de functie uit als volgt:

    function onMove(event)
    {
        const mx = d3.pointer(event);
        focus.attr("transform", `translate(${mx[0]},0)`);
    }

Dit zal ons focuselementje verplaatsen naar de juist x-coordinaat op onze grafiek. De volgende stap is om die te laten 'snappen' naar het dichtbijzijnste datapunt. Probeer gerust eerst eens zelf.

Willen we onze x-waarde vertalen naar een datum, dan kunnen we daar onze scaling function `x` voor gebruiken. Typisch voeren we die een datum en krijgen dan een pixelcoordinaat. Maar je kan dat ook omdraaien:

    const date = x.invert(...);

Probeer maar eens af te printen:

    const date = x.invert(mx[0]);
    console.log(date);

Nu we een datum hebben willen we het dichtbijzijnste datapunt weten. Daarvoor maken we opnieuw gebruik van een d3 snufje. Ditmaal een `bisect`. Bisect is, net zoals onze scaling functions, een manier om te zoeken in onze data op basis van een attribuut. Dat ziet er zo uit voor ons:

    const bisect = d3.bisector(d => d.date).center;

Een bisect kan `left`, `right` of `center` ingesteld zijn. Left betekent dat het datapunt zoeken dat net links ligt van onze gegeven datum, right geeft het eerstvolgende datapunt, en center probeert netjes te verdelen. Let op: `bisect` geeft geen `date` terug, maar wel een index! Bisect werkt bovendien alleen maar op gesorteerde data. We maken deze `bisect` aan in onze code en gebruiken  die in onze functie:


    function onMove(event) {

        const mx = d3.pointer(event);
        focus.attr("transform", `translate(${mx[0]},0)`);
        const date = x.invert(mx[0]);
        const closestDataIndex = bisect(data, date);
        const closestData = data[closestDataIndex].date;
    }

We zijn nu dus van pixel gegaan naar datum, nu moeten we terug naar onze pixel waarde. Daar hebben we gelukkig onze scaling function `x` voor.

✅ Pas bovenstaande code aan dat de cirkel snapt op `closestData`.
✅ Zorg dat ook de correct Y-coordinaat gebruikt wordt. Zie oplossing 7.
✅ Zorg dat je gestippelde lijn ook correct werkt!

## Interactiviteit: Tooltip
We kunnen ook onze eigen tooltips maken. We bouwen die nog eens op vanuit code, maar je kan die ook rechtstreeks in je HTML zetten:

    d3.select("body")
        .append("div")
        .style("position", "absolute")
        .style("background", "white")
        .style("padding", "6px 8px")
        .style("border-radius", "4px")
        .style("border", "1px solid #ddd")
        .style("box-shadow", "0 1px 4px rgba(0,0,0.1)")
        .style("display", "none");

✅ We willen dit div elementje zo dadelijk nog aanspreken, capteer het div elementje in een variabele genaamd `tooltip`. Tip: kijk nog eens goed naar hoe d3 selections werken. Zie oplossing 8.

Als je dit even wilt testen, laat dan de laatste regel weg. We gaan de tooltip tonen als we met de muis over een datapunt zweven. Voordat we de correct data tonen, laat ons eerst even kijken of we die tooltip al gewoon zichtbaar kunnen maken.
We maken de tooltip zichtbaar bij `mouseenter` en terug onzichtbaar bij `mouseleave`:

    svg.append("rect")
        .attr("fill", "transparent")
        .attr("pointer-events", "all")
        .attr("width", width)
        .attr("height", height)
        .on("mousemove", onMove)
        .on("mouseenter", () => { tooltip.style("display","block"); })
        .on("mouseleave", () => { tooltip.style("display","none"); });

✅ Zorg dat ons focus elementje op dezelfde manier zichtbaar en onzichtbaar gezet wordt.

We moeten nog de positie van onze tooltip juist zetten. Daarvoor hadden we positie van onze tooltip op `absolute` gezet. 
We gaan verder op `onMove`:

    ...
    tooltip.style("left", (event.pageX + 12) + "px")
    .style("top",  (event.pageY - 28) + "px");

Dit zet de tooltip aan onze muiscursor, met wat marge. We kunnen nu ook wat HTML invullen:

    tooltip
        .style("left", (event.pageX + 12) + "px")
        .style("top",  (event.pageY - 28) + "px")
        .html("<strong>Hallo</strong>");

We willen daar echter graag ons datapunt invullen, en dat hebben we gelukkig al berekend. Ik wil dat daar graag HTML komt in bijvoorbeeld de volgende vorm:

    <strong>JAN 1, 2025</strong><br/>Value: 22

Om je te helpen om die datum correct weer te geven verwijs ik graag terug naar `d3.timeFormat` dat we al hebben gebruikt. Je kan zo een time format capteren in een variabele net als een scale functie:

    const formatDate = d3.timeFormat("...");

✅ De tooltip moet nu het correct datapunt weergeven, in het format zoals hierboven aangegeven is. Zie oplossing 9.


## Oplossingen

### Oplossing 1

    const data = raw.map(d => ({ date: parseDate(d.date), value: +d.value }))
                .sort((a,b) => a.date - b.date);

### Oplossing 2

    const x = d3.scaleTime()
    .domain(d3.extent(data, d => d.date))
    .range([0, width]);

### Oplossing 3

    svg.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2)
        .attr("d", line);

### Oplossing 4

    const line = d3.line()
    .curve(d3.curveMonotoneX)
    .x(d => x(d.date))
    .y(d => y(d.value));

### Oplossing 5

    const area = d3.area()
        .x(d => x(d.date))
        .y0(y(0))
        .y1(d => y(d.value));

    svg.append("path")
        .datum(data)
        .attr("fill", "rgba(54, 162, 235, 0.2)")
        .attr("d", area);
        
### Oplosing 6

    svg.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(y).tickSize(-width).tickFormat(() => ""));

CSS:     

    .grid line { stroke: #eee; }

### Oplossing 7
    function onMove(event) {

        const mx = d3.pointer(event);
        const date = x.invert(mx[0]);
        const closestDataIndex = bisect(data, date);
        const closestData = data[closestDataIndex].date;
        const cx = x(closestData);
        const cy = y(data[closestDataIndex].value)
        focus.attr("transform", `translate(${cx},${cy})`);

    }

### Oplossing 8

    d3.select("body")
        .append("div")
        .attr("id", "tooltip")
        .style("position", "absolute")
        .style("background", "white")
        .style("padding", "6px 8px")
        .style("border-radius", "4px")
        .style("border", "1px solid #ddd")
        .style("box-shadow", "0 1px 4px rgba(0,0,0.1)")
        .style("display", "none")

    const tooltip = d3.select("#tooltip");

### Oplossing 9

    const formatDate = d3.timeFormat("%b %d, %Y");
    ...
    function onMove(event) {
        const mx = d3.pointer(event);
        const date = x.invert(mx[0]);
        const closestDataIndex = bisect(data, date);
        const closestData = data[closestDataIndex].date;
        const cx = x(closestData);
        const cy = y(data[closestDataIndex].value)
        focus.attr("transform", `translate(${cx},${cy})`);
        tooltip
        .style("left", (event.pageX + 12) + "px")
        .style("top",  (event.pageY - 28) + "px")
        .html(`<strong>${formatDate(closestData)}</strong><br/>Value: ${data[closestDataIndex].value}`);
    }