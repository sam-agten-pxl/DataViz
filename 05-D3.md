# Lab 05
In dit lab maken we kennis met D3. D3 is complexer maar ook veel flexibeler and uitgebreider dan Chart.js. In D3 kan je niet zomaar een lijngrafiek tekenenen maar moet je alle elementen zelf tekenenen. D3 denkt in termen van lijnen, rechthoeken en cirkels en niet in termen van grafieken. Maar belangrijker is dat D3 ons een hele hoop tools geeft om aan dataverwerking te doen. Wil je een simpele grafiek, dan kan je data eerst verwerken met D3 en dan tekenen met Chart.js.
Hier gaan we echter eerst even spelen met de grafische kant van D3, de dataverwerking zien we in een ander labo.

## Hello SVG
We beginnen nog eens opnieuw:

    npm create vite@latest

Projectnaam 'hellod3', 'vanilla' en 'javascript' selecteren.

    cd hellod3
    npm install

We gaan nog niet meteen D3 installeren, we gaan eerst eens experimenteren met SVG. SVG, oftewel Scalable Vector Graphics, ken je al van de lessen illustrator. SVG is een standaard onderdeel van HTML. De SVG elementen wij gaan gebruiken zijn `rect` (een rechthoek), `circle` (een cirkel), `line` (een lijn) en `text` (voor, jawel, tekst). Al deze elementen moeten getekend worden binnen een `svg` elementje. Bv:

    <svg width="400" height="200">
        <rect x="20" y="20" width="100" height="50" fill="orange" />
    </svg>

Laat ons dat gewoon eens proberen. Vervang je index.html door het volgende:

    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>SVG Voorbeeld</title>
    </head>
    <body>
    <h1>SVG Voorbeeld</h1>

    <svg width="400" height="200">
        <rect x="20" y="20" width="100" height="50" fill="orange" />

        <circle cx="200" cy="60" r="30" fill="steelblue" />

        <line x1="20" y1="150" x2="380" y2="150" stroke="black" stroke-width="2" />

        <text x="200" y="190" font-size="16" text-anchor="middle">
        Mijn eerste SVG
        </text>
    </svg>
    </body>
    </html>

...en run met:

    npm run dev

Meer valt er niet te vertellen over SVG! Je tekent op je canvas deze elementen. Zorg ervoor dat je steeds coordinaten meegeeft aan deze elementen. Let er ook op dat je niet buiten je canvas tekent. Ons `svg` element is 400px x 200p. Als ik een cirkel teken op cx=500 met een radius van 20, dan ga ik die niet zien.
Misschien ben je nu in de war door `cx` in de plaats van `x`. Voor een cirkel gebruiken we `cx` en `cy` in de plaats van `x` en `y` om het midden van de cirkel aan te geven. Ik zal hier geen uitgebreide documentatie geven over het gebruik van de individuele elementen. Je wordt verwacht dat zelf te kunnen uitzoeken.

✅ Zoek, op google of met AI, naar de belangrijkste properties van een svg `line`. 
✅ Zoek, op google of met AI, naar de belangrijkste properties van een svg `text`. 

## Hello D3
We installeren nu D3 (Vergeet niet je server plat te leggen met CTRL/CMD + C)

    npm install d3

Vervang je index.html door:

    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>D3 Voorbeeld</title>
    </head>
    <body>
    <h1>D3 Voorbeeld</h1>

    <svg id="mysvg" width="400" height="200"></svg>
    <script type="module" src="/src/main.js"></script>

    </body>
    </html>

Merk op dat we opnieuw ons script koppelen hier. Laat ons dat maar eens opendoen. Importeer eerst d3:

    import * as d3 from 'd3';

Een belangrijk onderdeel van D3 is **selecties**. Met selecties kan je via D3 elementen uit je DOM selecteren op basis van class of id, zoals we al gewoon zijn. In een vorig labo deden we bijvoorbeeld:

    const ctx = document.getElementById('graph-canvas');

Nu gaan we dat rechtstreeks doen met D3:

    const svg = d3.select('#mysvg')
    
Je kan `d3.select` doen maar nu kan ik ook `svg.select` doen. Als je select toepast op d3 rechtstreeks dan zal het hele html document doorzocht worden. Doe je select op een html element, dan zal enkel in de kinderelementen van dat element gezocht worden. Dat is uiteraard sneller en efficienter.
We gaan nu een `rect` elementje tekenen met d3:

    svg.append("rect")

Met `append` voeg je een elementje toe, in dit geval aan `svg`. Dat werkt, maar je gaat niets zien omdat deze `rect` geen positie of breedte/hoogte heeft. Dat kunnen we aanpassen met `attr`:

    const r = svg.append("rect");
    r.attr("x", 20);
    r.attr("y", 20);
    r.attr("width", 100);
    r.attr("height", 50);
    r.attr("fill", "orange");

Run en bekijk maar eens. 
Graag schrijven we dit beknopter zonder het gebruik van een variabele (`r` in dit geval):

     svg.append("rect")
      .attr("x", 20)
      .attr("y", 20)
      .attr("width", 100)
      .attr("height", 50)
      .attr("fill", "orange");

✅ Gebruik nu D3 om de rest van de tekening, die we daarnet rechtstreeks in HTML hebben gemaakt, te tekenen. De oplossing vind je als oplossig 1 hieronder.

We gaan nu onze eerste datavisualisatie maken met D3. Daarvoor hebben we uiteraard data nodig. Maak je JS file leeg op je import statement na en voeg de volgende data toe:

    const data = [10, 20, 30, 40, 50];

Selecteer ook je SVG elementje opnieuw, je weet ondertussen hoe dat moet. We gaan nu aan databinding doen en op eerste zicht kan dat wat lijken op magie. D3 doet aan databinding door middel van 2 hoofdingredienten: een selectie en een reeks data.
D3 gaat dan proberen om elk elementje uit de selectie te matchen met een elementje uit de data array. Als we in dit geval dus een selectie zouden maken van 5 elementjes en die koppelen aan onze data array, dan komt dat netjes uit. Helaas weten we dat vaak niet op voorhand natuurlijk omdat onze data dynamisch is. We zouden elementjes te veel of te weinig kunnen hebben.
Daarom vraag D3 om een `exit` en `enter` te bepalen voor elk elementje. Zijn er elementjes te veel? Dan zal het exit gedrag uitgevoerd worden voor elk elementje dat te veel is. We kunnen die dan bijvoorbeeld met een animatie gracieus het toneel laten verlaten. Zijn er elementjes te weinig? Dan zal D3 het enter gedrag uitvoeren dat we gespecifieerd hebben.

Genoeg geleuterd, we gaan dat gewoon eens stap voor stap doen. Ik begin met een selectie:

    svg.selectAll("circle");

Dit is een LEGE SELECTIE! Er zijn immers geen circle elementjes die een kind zijn van ons SVG element. Dus we starten met een lege selectie. Nu ga ik die lege selectie van cirkels verbinden aan onze data:

    svg.selectAll("circle")
    .data(data)

We verbinden nu 5 datapunten aan 0 elementjes. We komen er dus 5 te kort. D3 zal nu het `enter` gedrag willen uitvoeren voor elk elementje dat er te kort is. Als er een elementje ontbreekt voegen we een `circle` elementje toe. Dat kan, zoals we eerder hebben gezien, met `append`:


    svg.selectAll("circle")
    .data(data)
    .enter()
    .append("circle")
    
Zoals we ondertussen weten is dit niet voldoende. Die cirkel heeft geen `cx`, `cy` of `r`. Dat doen we met `attr`:

    svg.selectAll("circle")
    .data(data)
    .enter()
    .append("circle")
    .attr("cy", 100)
    .attr("cx", 80)
    .attr("r", 20)
    .attr("fill", "steelblue");

Run dit. Je zal 1 cirkel zien, niet 5. Waarom?

We tekenen wel degelijk 5 cirkels, hoera! Maar alle cirkels hebben dezelfde eigenschappen en worden op elkaar getekend. Hoe kunnen we die cirkels laten varieren op basis van hun toegewezen datapunt? Denk eraan, de eerste cirkel komt overeen met datapunt 10, de tweede met 20, de derde met 30, enz.
D3 geeft dit datapunt al mee aan elke cirkel, we moeten die data gewoon uitlezen en gebruiken. In de plaats van 80 toe te wijzen aan `cx` kunnen we een functie gebruiken. Die functie krijgt van D3 2 soorten input: het datapunt (10 voor de eerste, 20 voor de tweede, etc) en de index in de data (0 voor de eerste, 1 voor de tweede, etc). Dat ziet er zo uit:

    ...
    .attr("cx", (d, i) => (i + 1) * 80)
    ...

We passen de x-coordinaat aan voor elke cirkel op basis van het datapunt. Uitgeschreven gebeurt dit voor elke cirkel:

    1e cirkel: d = 10, i = 0    --->    cx = (0 + 1) * 80 = 80
    2e cirkel: d = 20, i = 1    --->    cx = (1 + 1) * 80 = 160
    3e cirkel: d = 30, i = 2    --->    cx = (2 + 1) * 80 = 240
    4e cirkel: d = 40, i = 3    --->    cx = (3 + 1) * 80 = 320
    5e cirkel: d = 50, i = 4    --->    cx = (4 + 1) * 80 = 400

Run opnieuw, je zal zien dat de cirkels nu netjes uit elkaar getekend worden. Proficiat, je hebt zonet je eerste datavisualisatie gedaan met D3? Ben je fier op jezelf? Ik ben fier op jou.

✅ Pas de visualisatie aan zodat de straal van de cirkels steeds de helft is van het toegewezen datapunt. Oplossing is oplossing 2.
✅ Visualizeer deze data nu als een bar chart. Voeg tevens assen toe.

## Het G elementje en Transform
Een zeer krachtig SVG elementje is `g`. Het is het SVG equivalent van `div` en staat voor group. Probeer de volgende html code eens:

    <svg id="mysvg" width="400" height="200">
        <g transform="translate(50, 100)">
            <circle r="30" fill="orange"></circle>
        </g>
    </svg>

Let hier op de `transform` eigenschap. Daarmee kunnen we de group een plaats geven. `circle` krijgt hier ook geen `cx` of `cy` en hebben dus hun standaardwaarde: 0. Toch zien we de cirkel omdat die een kindelementje is van `g`, en die staat op positie (50, 100). De cirkel wordt dus getekend vanaf (50, 100). Als we een `cx` zouden geven van 20 aan de cirkel dan zou die nog 20 pixels naar rechts gaan vanaf zijn parent, `g` en dus eindigen op 70.
Je kan dit best vergelijken met het groeperen van vormen, zoals in illustrator. Hiermee kunnen we complexere vormen gaan visualiseren. We gaan dit nu gebruiken om tekst te zetten onder onze cirkels. We starten door voor elk datapunt een `g` te maken, niet een `circle`:

    const groups = svg.selectAll("g")
        .data(data)
        .enter()
        .append("g")
        .attr("transform", (d, i) => `translate(${(i + 1) * 80}, 100)`);

Een paar zaken:

- We vangen het resultaat dit maal op in een variabele: `groups`, dit is opnieuw een d3 selectie
- Let op de afschuwelijk syntax om `transform` vorm te geven. Dat is omdat de transform eigenschap tekst is. Dus we zijn tekst aan het opstellen, dat kan je op veel verschillende manieren doen in Javascript en heb je normaal geizen al in andere vakken gezien. Als je wat minder gevoelige, en (volgens mij) leesbaardere syntax wilt, is er ook dit langer alternatief:

    .attr("transform", (d, i) => "translate(" + ((i + 1) * 80) + ", 100)");

We voegen nu aan elk `g` elementje een cirkel toe. Daarvoor kunnen we onze `groups` variabele gebruiken:

    groups.append("circle")
        .attr("r", d => d / 2)
        .attr("fill", "steelblue");

Merk op dat we die variabele eigenlijk niet nodig hadden. We hadden voor elk groep elementje meteen een cirkel kunnen appenden. De variabele heb ik echter gebruikt om de volgende opdracht gemakkelijker te maken:

✅ Breidt deze code uit op dezelfde manier zodat je nu ook een `text` elementje plaatst onder elke cirkel met daarin de data. Zie oplossing 3.

## Oplossingen

### Oplossing 1

     svg.append("rect")
      .attr("x", 20)
      .attr("y", 20)
      .attr("width", 100)
      .attr("height", 50)
      .attr("fill", "orange");

    svg.append("circle")
      .attr("cx", 200)
      .attr("cy", 60)
      .attr("r", 30)
      .attr("fill", "steelblue");

    svg.append("line")
      .attr("x1", 20)
      .attr("y1", 150)
      .attr("x2", 380)
      .attr("y2", 150)
      .attr("stroke", "black")
      .attr("stroke-width", 2);

    svg.append("text")
      .attr("x", 200)
      .attr("y", 190)
      .attr("font-size", 16)
      .attr("text-anchor", "middle")
      .text("Mijn eerste SVG");

### Oplossing 2
Een mogelijke oplossing is dit:

  .attr("r", (d, i) => d/ 2)

..maar als je de tweede parameter, i, niet gebruikt, kan je die ook weglaten:

  .attr("r", (d) => d/ 2)

### Oplossing 3

    groups.append("text")
    .attr("y", 40) 
    .attr("text-anchor", "middle")
    .attr("font-size", 12)
    .text(d => d);